Using Engines and Degraders to Generate Galaxy Samples with Errors and Biases
=============================================================================

author: John Franklin Crenshaw, Sam Schmidt, Eric Charles, others…

last run successfully: August 2, 2023

This notebook demonstrates how to use a RAIL Engines to create galaxy
samples, and how to use Degraders to add various errors and biases to
the sample.

Note that in the parlance of the Creation Module, “degradation” is any
post-processing that occurs to the “true” sample generated by the
Engine. This can include adding photometric errors, applying quality
cuts, introducing systematic biases, etc.

In this notebook, we will first learn how to draw samples from a RAIL
Engine object. Then we will demonstrate how to use the following RAIL
Degraders:

1. **LSSTErrorModel**, which adds photometric errors

2. **QuantityCut**, which applies cuts to the specified columns of the
   sample

3. **InvRedshiftIncompleteness**, which introduces sample incompleteness

4. **LineConfusion**, which introduces spectroscopic errors

Throughout the notebook, we will show how you can chain all these
Degraders together to build a more complicated degrader. Hopefully, this
will allow you to see how you can build your own degrader.

*Note on generating redshift posteriors*: regardless of what Degraders
you apply, when you use a Creator to estimate posteriors, the posteriors
will *always* be calculated with respect to the “true” distribution.
This is the whole point of the Creation Module – you can generate
degraded samples for which we still have access to the *true*
posteriors. For an example of how to calculate posteriors, see
``posterior-demo.ipynb``.

.. code:: ipython3

    import matplotlib.pyplot as plt
    from pzflow.examples import get_example_flow
    from rail.creation.engines.flowEngine import FlowCreator
    from rail.creation.degraders.spectroscopic_degraders import (
        InvRedshiftIncompleteness,
        LineConfusion,
    )
    from rail.creation.degraders.photometric_errors import LSSTErrorModel
    from rail.creation.degraders.quantityCut import QuantityCut
    from rail.core.stage import RailStage


Specify the path to the pretrained ‘pzflow’ used to generate samples
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: ipython3

    import pzflow
    import os
    
    flow_file = os.path.join(
        os.path.dirname(pzflow.__file__), "example_files", "example-flow.pzflow.pkl"
    )


We’ll start by setting up the Rail data store. RAIL uses
`ceci <https://github.com/LSSTDESC/ceci>`__, which is designed for
pipelines rather than interactive notebooks, the data store will work
around that and enable us to use data interactively. See the
``rail/examples/goldenspike/goldenspike.ipynb`` example notebook for
more details on the Data Store.

.. code:: ipython3

    DS = RailStage.data_store
    DS.__class__.allow_overwrite = True


“True” Engine
-------------

First, let’s make an Engine that has no degradation. We can use it to
generate a “true” sample, to which we can compare all the degraded
samples below.

Note: in this example, we will use a normalizing flow engine from the
`pzflow <https://github.com/jfcrenshaw/pzflow>`__ package. However,
everything in this notebook is totally agnostic to what the underlying
engine is.

The Engine is a type of RailStage object, so we can make one using the
``RailStage.make_stage`` function for the class of Engine that we want.
We then pass in the configuration parameters as arguments to
``make_stage``.

.. code:: ipython3

    n_samples = int(1e5)
    flowCreator_truth = FlowCreator.make_stage(
        name="truth", model=flow_file, n_samples=n_samples
    )



.. parsed-literal::

    Inserting handle into data store.  model: /opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/pzflow/example_files/example-flow.pzflow.pkl, truth


Let’s check that the Engine correctly read the underlying PZ Flow object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: ipython3

    flowCreator_truth.get_data("model")





.. parsed-literal::

    <pzflow.flow.Flow at 0x7f6413e70d10>



Now we invoke the ``sample`` method to generate some samples
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note that this will return a ``DataHandle`` object, which can keep both
the data itself, and also the path to where the data is written. When
talking to rail stages we can use this as though it were the underlying
data and pass it as an argument. This allows the rail stages to keep
track of where their inputs are coming from.

.. code:: ipython3

    samples_truth = flowCreator_truth.sample(n_samples, seed=0)
    print(samples_truth())
    print("Data was written to ", samples_truth.path)



.. parsed-literal::

    Inserting handle into data store.  output_truth: inprogress_output_truth.pq, truth
           redshift          u          g          r          i          z  \
    0      1.398944  27.667536  26.723337  26.032637  25.178587  24.695955   
    1      2.285624  28.786999  27.476589  26.640175  26.259745  25.865673   
    2      1.495132  30.011349  29.789337  28.200390  26.014826  25.030174   
    3      0.842594  29.306244  28.721798  27.353018  26.256907  25.529823   
    4      1.588960  26.273870  26.115387  25.950441  25.687405  25.466606   
    ...         ...        ...        ...        ...        ...        ...   
    99995  0.389450  27.270800  26.371506  25.436853  25.077412  24.852779   
    99996  1.481047  27.478113  26.735254  26.042776  25.204935  24.825092   
    99997  2.023548  26.990147  26.714737  26.377949  26.250343  25.917370   
    99998  1.548204  26.367432  26.206884  26.087980  25.876932  25.715893   
    99999  1.739491  26.881983  26.773064  26.553123  26.319622  25.955982   
    
                   y  
    0      23.994413  
    1      25.391064  
    2      24.304707  
    3      25.291103  
    4      25.096743  
    ...          ...  
    99995  24.737946  
    99996  24.224169  
    99997  25.613836  
    99998  25.274899  
    99999  25.699642  
    
    [100000 rows x 7 columns]
    Data was written to  output_truth.pq


Degrader 1: LSSTErrorModel
--------------------------

Now, we will demonstrate the ``LSSTErrorModel``, which adds photometric
errors using a model similar to the model from `Ivezic et
al. 2019 <https://arxiv.org/abs/0805.2366>`__ (specifically, it uses the
model from this paper, without making the high SNR assumption. To
restore this assumption and therefore use the exact model from the
paper, set ``highSNR=True``.)

Let’s create an error model with the default settings:

.. code:: ipython3

    errorModel = LSSTErrorModel.make_stage(name="error_model")


To see the details of the model, including the default settings we are
using, you can just print the model:

.. code:: ipython3

    errorModel





.. parsed-literal::

    <rail.creation.degraders.photometric_errors.LSSTErrorModel at 0x7f6413e70f10>



Now let’s add this error model as a degrader and draw some samples with
photometric errors.

.. code:: ipython3

    samples_w_errs = errorModel(samples_truth)
    samples_w_errs()



.. parsed-literal::

    Inserting handle into data store.  input: None, error_model
    Inserting handle into data store.  output_error_model: inprogress_output_error_model.pq, error_model




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>redshift</th>
          <th>u</th>
          <th>u_err</th>
          <th>g</th>
          <th>g_err</th>
          <th>r</th>
          <th>r_err</th>
          <th>i</th>
          <th>i_err</th>
          <th>z</th>
          <th>z_err</th>
          <th>y</th>
          <th>y_err</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>1.398944</td>
          <td>29.586672</td>
          <td>2.273363</td>
          <td>26.815650</td>
          <td>0.181360</td>
          <td>25.957766</td>
          <td>0.075960</td>
          <td>25.179779</td>
          <td>0.062270</td>
          <td>24.666717</td>
          <td>0.075660</td>
          <td>24.141031</td>
          <td>0.106938</td>
        </tr>
        <tr>
          <th>1</th>
          <td>2.285624</td>
          <td>28.109795</td>
          <td>1.128098</td>
          <td>27.494877</td>
          <td>0.317360</td>
          <td>26.728171</td>
          <td>0.148826</td>
          <td>26.269168</td>
          <td>0.161383</td>
          <td>26.077949</td>
          <td>0.254140</td>
          <td>26.269863</td>
          <td>0.597274</td>
        </tr>
        <tr>
          <th>2</th>
          <td>1.495132</td>
          <td>inf</td>
          <td>inf</td>
          <td>28.058257</td>
          <td>0.489873</td>
          <td>29.528996</td>
          <td>1.168987</td>
          <td>26.031911</td>
          <td>0.131603</td>
          <td>25.106268</td>
          <td>0.111318</td>
          <td>24.337457</td>
          <td>0.126875</td>
        </tr>
        <tr>
          <th>3</th>
          <td>0.842594</td>
          <td>inf</td>
          <td>inf</td>
          <td>28.631909</td>
          <td>0.734438</td>
          <td>27.719360</td>
          <td>0.338319</td>
          <td>26.301480</td>
          <td>0.165894</td>
          <td>25.490034</td>
          <td>0.155129</td>
          <td>26.575426</td>
          <td>0.737135</td>
        </tr>
        <tr>
          <th>4</th>
          <td>1.588960</td>
          <td>26.305300</td>
          <td>0.323528</td>
          <td>26.141795</td>
          <td>0.101461</td>
          <td>25.900682</td>
          <td>0.072221</td>
          <td>25.696127</td>
          <td>0.098222</td>
          <td>25.387878</td>
          <td>0.142099</td>
          <td>25.301173</td>
          <td>0.285425</td>
        </tr>
        <tr>
          <th>...</th>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
        </tr>
        <tr>
          <th>99995</th>
          <td>0.389450</td>
          <td>27.042212</td>
          <td>0.565632</td>
          <td>26.330871</td>
          <td>0.119639</td>
          <td>25.439945</td>
          <td>0.047993</td>
          <td>25.062687</td>
          <td>0.056125</td>
          <td>24.864382</td>
          <td>0.090063</td>
          <td>24.559099</td>
          <td>0.153585</td>
        </tr>
        <tr>
          <th>99996</th>
          <td>1.481047</td>
          <td>29.052011</td>
          <td>1.820704</td>
          <td>26.503314</td>
          <td>0.138888</td>
          <td>26.079875</td>
          <td>0.084602</td>
          <td>25.237278</td>
          <td>0.065526</td>
          <td>24.748012</td>
          <td>0.081289</td>
          <td>24.381392</td>
          <td>0.131794</td>
        </tr>
        <tr>
          <th>99997</th>
          <td>2.023548</td>
          <td>26.970381</td>
          <td>0.537064</td>
          <td>26.956356</td>
          <td>0.204176</td>
          <td>26.403214</td>
          <td>0.112333</td>
          <td>25.902136</td>
          <td>0.117589</td>
          <td>25.929637</td>
          <td>0.224849</td>
          <td>25.596682</td>
          <td>0.361166</td>
        </tr>
        <tr>
          <th>99998</th>
          <td>1.548204</td>
          <td>26.735890</td>
          <td>0.451577</td>
          <td>26.409908</td>
          <td>0.128124</td>
          <td>26.070832</td>
          <td>0.083930</td>
          <td>26.109223</td>
          <td>0.140687</td>
          <td>25.531333</td>
          <td>0.160707</td>
          <td>25.895538</td>
          <td>0.454344</td>
        </tr>
        <tr>
          <th>99999</th>
          <td>1.739491</td>
          <td>28.622287</td>
          <td>1.485375</td>
          <td>26.811960</td>
          <td>0.180795</td>
          <td>26.544316</td>
          <td>0.126994</td>
          <td>26.175830</td>
          <td>0.148984</td>
          <td>26.019049</td>
          <td>0.242122</td>
          <td>25.475503</td>
          <td>0.328246</td>
        </tr>
      </tbody>
    </table>
    <p>100000 rows × 13 columns</p>
    </div>



Notice some of the magnitudes are inf’s. These are non-detections. This
means those observed fluxes were negative. You can change the limit for
non-detections by setting ``sigLim=...``, where the value you set is the
minimum SNR. Setting ``ndFlag=...`` changes the value used to flag
non-detections.

Let’s plot the error as a function of magnitude

.. code:: ipython3

    fig, ax = plt.subplots(figsize=(5, 4), dpi=100)
    
    for band in "ugrizy":
        # pull out the magnitudes and errors
        mags = samples_w_errs.data[band].to_numpy()
        errs = samples_w_errs.data[band + "_err"].to_numpy()
    
        # sort them by magnitude
        mags, errs = mags[mags.argsort()], errs[mags.argsort()]
    
        # plot errs vs mags
        ax.plot(mags, errs, label=band)
    
    ax.legend()
    ax.set(xlabel="Magnitude (AB)", ylabel="Error (mags)")
    plt.show()




.. image:: 00_Quick_Start_in_Creation_files/00_Quick_Start_in_Creation_19_0.png


You can see that the photometric error increases as magnitude gets
dimmer, just like you would expect. Notice, however, that we have
galaxies as dim as magnitude 30. This is because the Flow produces a
sample much deeper than the LSST 5-sigma limiting magnitudes. There are
no galaxies dimmer than magnitude 30 because LSSTErrorModel sets
magnitudes > 30 equal to NaN (the default flag for non-detections).

Degrader 2: QuantityCut
-----------------------

Recall how the sample above has galaxies as dim as magnitude 30. This is
well beyond the LSST 5-sigma limiting magnitudes, so it will be useful
to apply cuts to the data to filter out these super-dim samples. We can
apply these cuts using the ``QuantityCut`` degrader. This degrader will
cut out any samples that do not pass all of the specified cuts.

Let’s make and run degraders that first adds photometric errors, then
cuts at i<25.3, which is the LSST gold sample.

.. code:: ipython3

    gold_cut = QuantityCut.make_stage(name="cuts", cuts={"i": 25.3})


Now we can stick this into a Creator and draw a new sample

.. code:: ipython3

    samples_gold_w_errs = gold_cut(samples_w_errs)



.. parsed-literal::

    Inserting handle into data store.  output_cuts: inprogress_output_cuts.pq, cuts


If you look at the i column, you will see there are no longer any
samples with i > 25.3. The number of galaxies returned has been nearly
cut in half from the input sample and, unlike the LSSTErrorModel
degrader, is not equal to the number of input objects. Users should note
that with degraders that remove galaxies from the sample the size of the
output sample will not equal that of the input sample.

One more note: it is easy to use the QuantityCut degrader as a SNR cut
on the magnitudes. The magnitude equation is :math:`m = -2.5 \log(f)`.
Taking the derivative, we have

.. math::


   dm = \frac{2.5}{\ln(10)} \frac{df}{f} = \frac{2.5}{\ln(10)} \frac{1}{\mathrm{SNR}}.

So if you want to make a cut on galaxies above a certain SNR, you can
make a cut

.. math::


   dm < \frac{2.5}{\ln(10)} \frac{1}{\mathrm{SNR}}.

For example, an SNR cut on the i band would look like this:
``QuantityCut({"i_err": 2.5/np.log(10) * 1/SNR})``.

Degrader 3: InvRedshiftIncompleteness
-------------------------------------

Next, we will demonstrate the ``InvRedshiftIncompleteness`` degrader. It
applies a selection function, which keeps galaxies with probability
:math:`p_{\text{keep}}(z) = \min(1, \frac{z_p}{z})`, where :math:`z_p`
is the ‘’pivot’’ redshift. We’ll use :math:`z_p = 0.8`.

.. code:: ipython3

    inv_incomplete = InvRedshiftIncompleteness.make_stage(
        name="incompleteness", pivot_redshift=0.8
    )


.. code:: ipython3

    samples_incomplete_gold_w_errs = inv_incomplete(samples_gold_w_errs)



.. parsed-literal::

    Inserting handle into data store.  output_incompleteness: inprogress_output_incompleteness.pq, incompleteness


Let’s plot the redshift distributions of the samples we have generated
so far:

.. code:: ipython3

    fig, ax = plt.subplots(figsize=(5, 4), dpi=100)
    
    zmin = 0
    zmax = 2.5
    
    hist_settings = {
        "bins": 50,
        "range": (zmin, zmax),
        "density": True,
        "histtype": "step",
    }
    
    ax.hist(samples_truth()["redshift"], label="Truth", **hist_settings)
    ax.hist(samples_gold_w_errs()["redshift"], label="Gold", **hist_settings)
    ax.hist(
        samples_incomplete_gold_w_errs()["redshift"],
        label="Incomplete Gold",
        **hist_settings
    )
    ax.legend(title="Sample")
    ax.set(xlim=(zmin, zmax), xlabel="Redshift", ylabel="Galaxy density")
    plt.show()




.. image:: 00_Quick_Start_in_Creation_files/00_Quick_Start_in_Creation_30_0.png


You can see that the Gold sample has significantly fewer high-redshift
galaxies than the truth. This is because many of the high-redshift
galaxies have i > 25.3.

You can further see that the Incomplete Gold sample has even fewer
high-redshift galaxies. This is exactly what we expected from this
degrader.

Degrader 4: LineConfusion
-------------------------

``LineConfusion`` is a degrader that simulates spectroscopic errors
resulting from the confusion of different emission lines.

For this example, let’s use the degrader to simulate a scenario in which
which 2% of [OII] lines are mistaken as [OIII] lines, and 1% of [OIII]
lines are mistaken as [OII] lines. (note I do not know how realistic
this scenario is!)

.. code:: ipython3

    OII = 3727
    OIII = 5007
    
    lc_2p_0II_0III = LineConfusion.make_stage(
        name="lc_2p_0II_0III", true_wavelen=OII, wrong_wavelen=OIII, frac_wrong=0.02
    )
    lc_1p_0III_0II = LineConfusion.make_stage(
        name="lc_1p_0III_0II", true_wavelen=OIII, wrong_wavelen=OII, frac_wrong=0.01
    )


.. code:: ipython3

    samples_conf_inc_gold_w_errs = lc_1p_0III_0II(
        lc_2p_0II_0III(samples_incomplete_gold_w_errs)
    )



.. parsed-literal::

    Inserting handle into data store.  output_lc_2p_0II_0III: inprogress_output_lc_2p_0II_0III.pq, lc_2p_0II_0III


.. parsed-literal::

    Inserting handle into data store.  output_lc_1p_0III_0II: inprogress_output_lc_1p_0III_0II.pq, lc_1p_0III_0II


Let’s plot the redshift distributions one more time

.. code:: ipython3

    fig, ax = plt.subplots(figsize=(5, 4), dpi=100)
    
    zmin = 0
    zmax = 2.5
    
    hist_settings = {
        "bins": 50,
        "range": (zmin, zmax),
        "density": True,
        "histtype": "step",
    }
    
    ax.hist(samples_truth()["redshift"], label="Truth", **hist_settings)
    ax.hist(samples_gold_w_errs()["redshift"], label="Gold", **hist_settings)
    ax.hist(
        samples_incomplete_gold_w_errs()["redshift"],
        label="Incomplete Gold",
        **hist_settings
    )
    ax.hist(
        samples_conf_inc_gold_w_errs()["redshift"],
        label="Confused Incomplete Gold",
        **hist_settings
    )
    ax.legend(title="Sample")
    ax.set(xlim=(zmin, zmax), xlabel="Redshift", ylabel="Galaxy density")
    plt.show()




.. image:: 00_Quick_Start_in_Creation_files/00_Quick_Start_in_Creation_36_0.png


You can see that the redshift distribution of this new sample is
essentially identical to the Incomplete Gold sample, with small
perturbations that result from the line confusion.

However the real impact of this degrader isn’t on the redshift
distribution, but rather that it introduces erroneous spec-z’s into the
photo-z training sets! To see the impact of this effect, let’s plot the
true spec-z’s as present in the Incomplete Gold sample, vs the spec-z’s
listed in the new sample with Oxygen Line Confusion.

.. code:: ipython3

    fig, ax = plt.subplots(figsize=(6, 6), dpi=85)
    
    ax.scatter(
        samples_incomplete_gold_w_errs()["redshift"],
        samples_conf_inc_gold_w_errs()["redshift"],
        marker=".",
        s=1,
    )
    
    ax.set(
        xlim=(0, 2.5),
        ylim=(0, 2.5),
        xlabel="True spec-z (in Incomplete Gold sample)",
        ylabel="Spec-z listed in the Confused sample",
    )
    plt.show()




.. image:: 00_Quick_Start_in_Creation_files/00_Quick_Start_in_Creation_38_0.png


Now we can clearly see the spec-z errors! The galaxies above the line
y=x are the [OII] -> [OIII] galaxies, while the ones below are the
[OIII] -> [OII] galaxies.



